# this code is auto generated by the expr_codegen
# https://github.com/wukan1986/expr_codegen
# 此段代码由 expr_codegen 自动生成，欢迎提交 issue 或 pull request
from typing import TypeVar

import polars as pl  # noqa
import polars.selectors as cs  # noqa

# from loguru import logger  # noqa
from polars import DataFrame as _pl_DataFrame
from polars import LazyFrame as _pl_LazyFrame

# ===================================
# 导入优先级，例如：ts_RSI在ta与talib中都出现了，优先使用ta
# 运行时，后导入覆盖前导入，但IDE智能提示是显示先导入的
_ = 0  # 只要之前出现了语句，之后的import位置不参与调整
# from polars_ta.prefix.talib import *  # noqa
from polars_ta.prefix.tdx import *  # noqa
from polars_ta.prefix.ta import *  # noqa
from polars_ta.prefix.wq import *  # noqa
from polars_ta.prefix.cdl import *  # noqa
from polars_ta.prefix.vec import *  # noqa

DataFrame = TypeVar("DataFrame", _pl_LazyFrame, _pl_DataFrame)
# ===================================

_ = ["OPEN", "DOJI", "HIGH", "CLOSE", "LOW"]
[OPEN, DOJI, HIGH, CLOSE, LOW] = [pl.col(i) for i in _]

_ = ["_x_1", "_x_2", "_x_0", "RETURN_CC_1", "_x_3", "RETURN_CO_1", "RETURN_OC_1", "NEXT_DOJI", "RETURN_OO_1", "RETURN_OO_5"]
[_x_1, _x_2, _x_0, RETURN_CC_1, _x_3, RETURN_CO_1, RETURN_OC_1, NEXT_DOJI, RETURN_OO_1, RETURN_OO_5] = [pl.col(i) for i in _]

_DATE_ = "date"
_ASSET_ = "asset"
_NONE_ = None
_TRUE_ = True
_FALSE_ = False


def unpack(x: pl.Expr, idx: int = 0) -> pl.Expr:
    return x.struct[idx]


def cs_label(cond, x, q=20):
    """表达式太长，可自己封装一下。tool.all中指定extra_codes可以自动复制到目标代码中

    注意：名字需要考虑是否设置前缀`ts_`、`cs_`
    内部函数前缀要统一，否则生成的代码混乱。
    如cs_label与内部的cs_bucket、cs_winsorize_quantile是统一的
    """
    return if_else(cond, None, cs_qcut(cs_quantile(x, 0.01, 0.99), q))


def func_0_ts__asset(df: DataFrame) -> DataFrame:
    # ========================================
    df = df.with_columns(
        _x_1=(ts_delay(CLOSE, -1)).over(CLOSE.is_not_null(), _ASSET_, order_by=_DATE_),
        _x_2=(ts_delay(OPEN, -1)).over(OPEN.is_not_null(), _ASSET_, order_by=_DATE_),
    )
    return df


def func_0_cl(df: DataFrame) -> DataFrame:
    # ========================================
    df = df.with_columns(
        _x_0=1 / CLOSE,
        DOJI=four_price_doji(OPEN, HIGH, LOW, CLOSE),
    )
    # ========================================
    df = df.with_columns(
        RETURN_CC_1=-_x_0 * (CLOSE - _x_1),
        _x_3=1 / _x_2,
        RETURN_CO_1=-_x_0 * (CLOSE - _x_2),
        RETURN_OC_1=-1 + _x_2 / _x_1,
    )
    return df


def func_1_ts__asset(df: DataFrame) -> DataFrame:
    # ========================================
    df = df.with_columns(
        NEXT_DOJI=(ts_delay(DOJI, -1)).over(DOJI.is_not_null(), _ASSET_, order_by=_DATE_),
    )
    # ========================================
    df = df.with_columns(
        RETURN_OO_1=(_x_3 * ts_delay(OPEN, -2) - 1).over(pl.all_horizontal(OPEN.is_not_null(), _x_3.is_not_null()), _ASSET_, order_by=_DATE_),
        RETURN_OO_5=(_x_3 * ts_delay(OPEN, -6) - 1).over(pl.all_horizontal(OPEN.is_not_null(), _x_3.is_not_null()), _ASSET_, order_by=_DATE_),
    )
    return df


"""
#========================================func_0_ts__asset
_x_1 = ts_delay(CLOSE, -1) #
_x_2 = ts_delay(OPEN, -1) #
#========================================func_0_cl
_x_0 = 1/CLOSE #
DOJI = four_price_doji(OPEN, HIGH, LOW, CLOSE) # noqa
#========================================func_0_cl
RETURN_CC_1 = -_x_0*(CLOSE - _x_1) #
_x_3 = 1/_x_2 #
RETURN_CO_1 = -_x_0*(CLOSE - _x_2) #
RETURN_OC_1 = -1 + _x_2/_x_1 #
#========================================func_1_ts__asset
NEXT_DOJI = ts_delay(DOJI, -1) #
#========================================func_1_ts__asset
RETURN_OO_1 = _x_3*ts_delay(OPEN, -2) - 1 #
RETURN_OO_5 = _x_3*ts_delay(OPEN, -6) - 1 #
"""

"""
DOJI = four_price_doji(OPEN, HIGH, LOW, CLOSE) # noqa
NEXT_DOJI = ts_delay(DOJI, -1) #
RETURN_CC_1 = -1*1 + ts_delay(CLOSE, -1)/CLOSE #
RETURN_CO_1 = -1*1 + ts_delay(OPEN, -1)/CLOSE #
RETURN_OC_1 = -1*1 + ts_delay(OPEN, -1)/ts_delay(CLOSE, -1) #
RETURN_OO_1 = ts_delay(OPEN, -2)/ts_delay(OPEN, -1) - 1*1 #
RETURN_OO_5 = ts_delay(OPEN, -6)/ts_delay(OPEN, -1) - 1*1 #
"""


def _filter_last(df: DataFrame, ge_date_idx: int) -> DataFrame:
    """过滤数据，只取最后几天。实盘时可用于减少计算量"""
    if ge_date_idx == 0:
        return df
    else:
        return df.filter(pl.col(_DATE_) >= df.select(pl.col(_DATE_).unique().sort())[ge_date_idx, 0])


def main(df: DataFrame, ge_date_idx: int) -> DataFrame:

    df = func_0_ts__asset(df.sort(_ASSET_, _DATE_)).drop(*[])
    df = func_0_cl(df).drop(*["_x_2", "_x_0", "_x_1"])
    df = func_1_ts__asset(df.sort(_ASSET_, _DATE_)).drop(*["_x_3"])
    df = _filter_last(df, ge_date_idx)

    # drop intermediate columns
    # df = df.select(pl.exclude(r'^_x_\d+$'))
    df = df.select(~cs.starts_with("_"))

    # shrink
    df = df.select(cs.all().shrink_dtype())

    return df
